---
### 리눅스 명령어
---
**1) top**  
top 명령어란?  
: 실시간으로 CPU 사용률을 체크해주는 도구, 리눅스를 사용하는 서버의 성능이나 현재 돌아가고 있는 상활을 볼 때 사용   
- 명령어 사용법 >> **top [option]**
- 명령어 옵션 (대부분 옵션은 shift를 통한 명령을 주로 사용)   
  | 옵션      | 기능                               |  
  |-----------|------------------------------------|  
  | shift + p | CPU 사용률 내림차순                |  
  | shift + m | 메모리 사용률 내림차순             |  
  | shift + t | 프로세스가 실행되고 있는 시간 순서 |
- TOP 정보 시스템 내용(예시 사진첨부)
![image](https://user-images.githubusercontent.com/97009141/172032123-f9531f97-72eb-44a0-93b7-8720035b76fd.png)   
  | 13:47:52      | 현재 서버의 시간                                                                                |
  |---------------|------------------------------------------------------------------------------------------------|
  | 9 days, 5:24  | uptime(켜져 있는 시간)                                                                          |
  | 3 users       | users                                                                                           |
  | load average  | 현재 시스템이 얼마나 일을 하고 있는지 1/5/15분 단위로 실행<br>대기 중인 프로세스 수를 나타냄 |
  | Tasks         | 프로세스 개수                                                                                   |
  
**2) ps**   
ps 명령어란?   
: 현재 실행중인 프로스세스 목록을 보여주는 도구, 리눅스 OS관리 시 프로세스를 확인하는 경우 사용
- 명령어 사용법 >> **ps [option]**   
- 명령어 옵션 (grep명령어와 함께 사용하기 때문에 이외의 옵션은 잘 사용하지 않음)
  | 옵션  | 기능                            |
  |-------|---------------------------------|
  | -e    | 모든 프로세스 출력              |
  | -f    | 풀 포맷으로 보여줌(UID, PID 등) |
  | -l    | 긴 포맷으로 보여줌              |
  | p, -p | 특정 PID의 프로세스를 보여줌    |
  | -u    | 특정 사용자의 프로세스를 보여줌 |
  
**3) jobs**   
jobs 명령어란?
: 작업의 상태를 표시하는 명령어, 혀재 쉘 세셴에서 실행시킨 백그라운드 작업의 목룍이 출력   
- 명령어 사용법 >> **jobs [옵션][작업번호]**
- 명령어 옵션
  | 옵션    | 기능                                       |
  |---------|--------------------------------------------|
  | -l      | 프로세스 그룹 ID를 state 필드 앞에 출력    |
  | -n      | 프로세스 그룹 중에 대표 프로세스 ID를 출력 |
  | -p      | 각 프로세스 ID에 대한 한 행씩 출력         |
  | command | 지정한 명령어를 실행                       |
- jobs로 출력되는 백그라운드 작업의 상태값
  | Running          | 작업이 계속 진행중                       |
  |------------------|------------------------------------------|
  | Done             | 작업이 완료되어 0을 반환                 |
  | Done(code)       | 작업이 종료되었으며 0이 아닌 코드를 반환 |
  | Stopped          | 작업이 일시 중단                         |
  | Stopped(SIGTSTP) | SIGTSTP 시그널이 작업을 일시 중단        |
  | Stopped(SIGSTOP) | SIGSTOP 시그널이 작업을 일시 중단        |
  | Stopped(SIGTTIN) | SIGTTIN 시그널이 작업을 일시 중단        |
  | Stopped(SIGTTOU) | SIGTTOU 시그널이 작업을 일시 중단        |

**4) kill**  
kill 명령어란?   
: kill명령어는 대개 프로세스를 죽일 떄 사용, 내부적으로는 프로세스에 시그널을 보내 원하는 작업을 하게 함
- 명령어 사용법 >> **kill [option]**
- 명령어 옵션   
  | 옵션 | 기능            |
  |----|------------------|
  | -l | 시그널 리스트 확인 |
- 주요 시그널   
  | 시그널  | 영어              | 설명                                           |
  |---------|-------------------|------------------------------------------------|
  | SIGHUP  | Hang Up           | 세션이 종료될 때 시스템이 내리는 시그널        |
  | SIGINT  | Interrupt         | Ctrl + C, 종료 요청 시그널                     |
  | SIGKILL | Kill              | 강제 종료 시그널                               |
  | SIGSEGV | Segment Violation | 메모리 침범이 일어날 때 시스템이 보내는 시그널 |
  | SIGTERM | Terminate         | 기본 값, 종료 요청 시그널                      |
  | SIGTSTP | Temporary Stop    | Ctrl + Z 일시 중지 요청 시그널                 |
---
### vim 에디터에서 매크로 사용방법
---
매크로란?
: 특정한 움직임 또는 입력을 키에 저장함으로써 단순하면서 반복되는 동작을 쉽고 빠르게 해주는것을 말함.

- **vim에서 매크로 사용방법(순서)**
1. q + 알파벳(여기서는 a로 통칭) : a키에 recoding 시작
2. 반복을 위한 내가 원하는 동작 실행
3. q : recoding 종료
4. @a : 1회 실행
5. @@ : 방금한 매크로 실행
6. 10@a : 매크로 10번 실행

- **매크로 응용(숫자증가) **
1. 숫자 '1' 입력
2. 매크로 시작
3. 숫자 '1'을 복사해서 다음줄에 붙여넣기
4. 두번째 줄 '1'에 커서를 올리고 **Ctrl + a**(숫자증가)
5. 매크로 종료   
<참고>   
*>> Ctrl + a (숫자 증가)*   
*>> Ctrl + x (숫자 감소)*
